# 网络相关

## 网络模型

### 传输层

传输层协议定义了**不用主机上**的**不同进程间**提供了逻辑通信的功能。传输层只工作在**端系统中**。

### 应用层

应用层协议定义了**应用进程间的交互和通信规则**，不同主机的应用进程间如何相互传递报文，比如传递的报文的类型、格式、 有哪些字段等等。

## 输入url后发生了什么

![image-20201017215424474](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAAAAACIM/FCAAACh0lEQVR4Ae3ch5W0OgyG4dt/mQJ2xgQPzJoM1m3AbALrxzrf28FzsoP0HykJEEAAAUQTBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQQAABBBBAAAEEkKK0789+GK/I2ezfQB522PnS1qc8pGgXvr4tE4aY0XOUWlGImThWgyCk6DleixzE7qwBkg/MGiDPlVVAyp1VQGrPKiACDhFI6VkF5LmzCki+sg7IwDoglnVAil0IMkeG9CyUiwsxLFUVFzJJOQaKCjFCDN9RXMjIX7W6ztZXZDKKCyn8sWJvH+nca7WHDN9lROlAliPH9iRKCPI4cswFJQWxB46toLQgQ9jhn5QYZA9DOkoMUoQde5YapAxDWkoNYsOQR3KQd9CxUnIQF4S49CB9ENKlBxmDEKsFUgMCCCCAAHIrSF61f6153Ajy8nyiPr8L5MXnmm4CyT2fzN4DUvHZ+ntA2tOQBRBAAAEEEEAAAQQQ7ZBaC6TwSiDUaYHQ2yuB0MN+ft+43whyrs4rgVCjBUKTFshLC6TUAjGA3AxSaYFYLZBOC2RUAsk8h5qTg9QcbEoOsoQhQ2qQhsO5xCD5dgB5JQaZ+KBKGtKecvR81Ic0ZDjByKdDx0rSEDZ/djQbH+bkIdvfJFm98BfV8hD2zprfVdlu9PxVeyYAkciREohRAplJCaRSAplJCcQogTjSAdlyHRBvSAekJR0QRzogA+mADJkOiCPSAPEtqYBshlRAXC43hxix2QiOuEZkVERykGyNo9idIZKE0HO7XrG6OiMShlDWjstVzdPgXtUH9v0CEidAAAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQQP4HgjZxTpdEii0AAAAASUVORK5CYII=)

1. 浏览器主线程接管，新开一个下载线程
2. 发送HTTP请求（包括DNS查询IP、IP寻址等过程）
3. 建立TCP连接（3次握手），浏览器等待响应
4. 服务器处理请求
5. 服务器返回响应结果，浏览器下载响应报文，将下载完的内容交给Renderer进程管理
6. 浏览器解析DOM树和CSSOM树，这个过程是**并行**的，因此一般将link标签放在页面顶部
7. 浏览器合成渲染树，并计算每个节点的位置，生成布局树，然后进行图像绘制
8. 浏览器渲染结束后，关闭TCP连接（4次挥手）

## ip相关

### www

> www：World Wide Web万维网

- Internet提供了很多服务，其中包括WWW(网页服务)、FTP(文件传输)、E-mail(电子邮件)、Telnet(远程登录)等等。
- www是用浏览器访问网页的服务，所以网站的主页的域名前需要加www。
- 而随着网站服务类型的增加，**不同的二级或三级域名对应不同的业务，而业务的处理任务会分配到多个服务器**，所以www不再标注是浏览网页的服务，也不再需要使用www来标注主页
- 很多网站都还会做DNS解析www,原因是尊重用户习惯。(国外网站基本不用www标注主页github)。

> 域名级别

- 顶级域名（一级域名）：4399.com
- 二级域名：www.4399.com play.4399.com
- 三级域名：yule.play.4399.com

### IP地址

- Internet Protocol Address
- 中文：互联网协议地址、IP地址
- 作用：分配给用户上网使用的互联网协议
- 分类：IPv4 IPv6 其他
- 形式：192.168.0.1（长度32位（4个字节），十进制表示）（IPv4）
- v：version
- 4或6：版本号
- IPv6优势：
  - 地址空间更大（8组（128位），十六进制）
  - 路由表更小
  - 组播支持以及对流支持增强
  - 对自动配置的支持
  - 更高的安全性
  - ABCD:EF01:2345:6789:ABCD:EF01:2345:6789

#### IP地址的分类

![image-20210318233547585](https://gitee.com/lu_jianping/the-front-end-knowledge/raw/master/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3.assets/image-20210318233547585.png)

### 端口号PORT

- 每个端口对应的是一个服务器的一个业务，访问一个服务器的不同端口相当于访问不同的业务
- 端口号范围：0-65535
- 默认端口：http协议下（80）、https协议下（443）、FTP协议下（20、21）
- node展示端口不同，服务端不同的业务

### DNS协议相关

#### 概况

- DNS：Domain Name Server（域名服务器）
- DNS协议提供的是一种将**主机名到IP地址**的**转换服务**，就是我们常说的**域名系统**。
- 它是一个由**分层的DNS服务器**组成的**分布式数据库**，同时定义了主机如何**查询这个分布式数据库**的方式的**应用层协议**。
- DNS协议运行在**UDP协议**之上，使用**53号**端口。
- **特征**：DNS中保存了一张域名与对应的IP地址的表，一个域名对应一个IP地址，一个IP地址可以对应多个域名

#### 域名的层次结构

域名的层级结构可以如下

```
主机名.次级域名.顶级域名.根域名
# 即
host.sld.tld.root
```

根据域名的层级结构，管理不同层级域名的服务器，可以分为**根域名服务器**、**顶级域名服务器**和**权威域名服务器**。

- gTLD：generic Top-Level DNS Server 顶级域名服务器，为所有.com、.net...后缀做域名解析的服务器

#### DNS查询过程

客户端收到你输入的域名地址后，它首先去找**本地的hosts文件**，检查在该文件中是否有相应的域名、IP对应关系，如果有，则向其IP地址发送请求，如果没有，再去找**DNS服务器**查询。

![image-20201017220916041]()

DNS 的查询过程一般为，我们首先**将 DNS 请求发送到本地 DNS 服务器**，由本地 DNS 服务器来**代为请求**。

1. 从"根域名服务器"查到"顶级域名服务器"的 NS 记录和 A 记录（ IP 地址）。
2. 从"顶级域名服务器"查到"次级域名服务器"的 NS 记录和 A 记录（ IP 地址）。
3. 从"次级域名服务器"查出"主机名"的 IP 地址。

比如我们如果想要查询 [www.baidu.com](http://www.baidu.com/) 的 IP 地址，我们首先会将请求发送到本地的 DNS 服务器中，本地 DNS 服务器会判断**是否存在该域名的缓存**，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名服务器的 IP 地址的列表。

然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。

然后本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。

#### DNS记录和报文

DNS 服务器中以资源记录的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为

（Name，Value，Type，TTL）

其中 **TTL 是资源记录的生存时间**，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间。

常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，不同 Type 的值，对应资源记录代表的意义不同。

#### DNS 缓存

DNS 缓存的原理非常简单，在一个请求链中，当某个 DNS 服务器接收到一个 DNS 回答后，它能够将回答中的信息缓存在本地存储器中。返回的资源记录中的 TTL 代表了该条记录的缓存的时间。

## TCP协议相关

### TCP（打电话）

- TCP：Transmission Control Protocol 传输控制协议
- 特点：**面向连接**（收发数据前，必须建立**可靠**的连接）
- 建立连接基础：三次握手
- 应用场景：数据必须**准确无误**的收发（HTTP请求、FTP文件传输、邮件收发）
- 优点：**稳定、重传机制、拥塞控制机制、断开连接**
- 缺点：**速度慢、效率低、占用资源、容易被攻击**（三次握手->容易被DOS、DDOS攻击）
- TCP/IP协议组：提供**点对点**的连接机制，制定了数据封装、定制、传输、路由、数据接收的标准

#### TCP头格式

![image-20210314204403623](https://gitee.com/lu_jianping/the-front-end-knowledge/raw/master/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3.assets/image-20210314204403623.png)

**序列号**：在建立连接时由计算机生成的**随机数**作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。**用来解决网络包乱序问题。**

**确认应答号**：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。**用来解决不丢包的问题。**

**控制位：**

- ACK：该位为 `1` 时，**「确认应答」的字段变为有效**，TCP 规定除了最初建立连接时的 `SYN` 包之外该位必须设置为 `1`
- RST：*RST*：该位为 `1` 时，表示 TCP 连接中出现异常必须强制断开连接。
- SYC：该位为 `1` 时，表示**希望建立连接**，并在其「序列号」的字段进行序列号初始值的设定。
- FIN：该位为 `1` 时，表示**今后不会再有数据发送**，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 `FIN` 位置为 1 的 TCP 段。

#### TCP协议工作层，重要性？

- `IP` 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。
- TCP 是一个工作在**传输层**的**可靠**数据传输的服务，它能确保接收端接收的网络包是**无损坏、无间隔、非冗余和按序的。**

#### TCP的特点，定义

TCP 是**面向连接的、可靠的、基于字节流**的传输层通信协议。

- **面向连接**：一定是**「一对一」**才能连接，不能像 UDP 协议 可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；
- **可靠的**：无论的网络链路中出现了怎样的链路变化，TCP 都可以**保证一个报文一定能够到达接收端**；
- **字节流**：消息是「没有边界」的，所以**无论我们消息有多大都可以进行传输**。并且消息是「有序的」，当「前一个」消息没有收到的时候，即使它先收到了后面的字节，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃。

#### 唯一确定一个TCP连接

TCP 四元组可以唯一的确定一个连接，四元组包括如下：

- 源地址
- 源端口
- 目的地址
- 目的端口

源地址和目的地址的字段（32位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。

源端口和目的端口的字段（16位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。

### UDP（喇叭喊人）

- UDP：User Data Protocol 用户数据报协议
- 特点：面向**无连接**（**不可靠**的协议，无状态传输机制）
- 无连接信息发送机制（没有握手的过程，没有建立连接的时延，不需要在端系统中保持连接的状态）
- 只提供了传输层需要实现的**最低限度的功能**，除了复用/分解功能和少量的差错检测外，它几乎没有对 IP 增加其他的东西
- UDP 没有拥塞控制和流量控制的机制，所以 UDP 报文段的发送速率没有限制。
- 因为一个 UDP 套接字**只使用目的地址和目的端口**来标识，所以 UDP **可以支持一对一、一对多、多对一和多对多**的交互通信。
- 应用场景：无需确保通讯质量且要求速度快、无需确保信息完整
  - 消息收发、语音通话、直播（QQ）
- 优点：安全、快速、漏洞小（UDP flood攻击）
- 缺点：不可靠、不稳定、容易丢包
- 总结：只要目的源地址、端口号、发送方地址、端口号确定，则可以直接发送信息报文，但不能保证一定能收到或者收到完整的数据

![image-20210314210855264](https://gitee.com/lu_jianping/the-front-end-knowledge/raw/master/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3.assets/image-20210314210855264.png)

UDP 报文段由首部和应用数据组成。报文段首部包含四个字段，分别是**源端口号**、**目的端口号**、**长度和检验和**，每个字段的长度为两个字节。长度字段指的是整个报文段的长度，包含了首部和应用数据的大小。

校验和是 UDP 提供的一种差错校验机制。虽然提供了差错校验的机制，但是 UDP **对于差错的恢复无能为力**。

#### TCP和UDP的区别

*1. 连接*

- TCP 是面向连接的传输层协议，传输数据前先要建立连接。
- UDP 是不需要连接，即刻传输数据。

*2. 服务对象*

- TCP 是一对一的两点服务，即一条连接只有两个端点。
- UDP 支持一对一、一对多、多对多的交互通信

*3. 可靠性*

- TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。
- UDP 是尽最大努力交付，不保证可靠交付数据。

*4. 拥塞控制、流量控制*

- TCP 有拥塞控制和流量控制机制，保证数据传输的**安全性**。
- UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。

#### TCP和UDP的应用场景

- 由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：
  - `FTP` 文件传输
  - `HTTP` / `HTTPS`
- 由于 UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：
  - 包总量较少的通信，如 `DNS` 、`SNMP` 等
  - 视频、音频等多媒体通信
  - 广播通信

### TCP协议数据格式

![image-20201018220913324]()

#### 建立TCP连接的前奏

- 标志位：数据包
  - SYN：Synchronize Sequence Numbers 同步序列编号
  - ACK：Acknowledgement 确认字符
- 状态：
  - LISTEN：侦听TCP端口的连接请求（我等着你发送连接请求）
  - SYN-SENT：在发送连接请求后等待匹配的连接请求（我发送了连接请求，我等你回复）
  - SYN-RECEIVED：在收到和发送一个连接请求后等待对连接请求的确认，我收到你的连接请求，我等你回复我
  - ESTABLISHED：代表一个打开的连接，数据可以传送给用户（连接建立了，我跟你说一下）

![image-20201018214002381]()

![image-20210316224427975](https://gitee.com/lu_jianping/the-front-end-knowledge/raw/master/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3.assets/image-20210316224427975.png)

#### 建立TCP的三次握手总结

- 一开始，客户端和服务端都处于 `CLOSED` 状态。先是服务端主动监听某个端口，处于 `LISTEN` 状态
- **第一次握手**：客户端会随机初始化序号（`client_isn`），将此序号置于 TCP 首部的「序号」字段中，同时把 `SYN` 标志位置为 `1` ，表示 `SYN` 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于`SYN-SENT` 状态
- **第二次握手**：服务端收到客户端的 `SYN` 报文后，首先服务端也随机初始化自己的序号（`server_isn`），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 `client_isn + 1`, 接着把 `SYN` 和 `ACK` 标志位置为`1`。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 `SYN-RCVD` 状态。
- **第三次握手**：客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 `ACK` 标志位置为 `1` ，其次「确认应答号」字段填入 `server_isn + 1` ，最后把报文发送给服务端，这次报文**可以携带客户端到服务器的数据**，之后客户端处于 `ESTABLISHED` 状态。

#### 为什么是三次握手？不是两次、四次？

**TCP 连接**：

- 用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括**Socket、序列号和窗口大小**称为连接。

所以，重要的是**为什么三次握手才可以初始化Socket、序列号和窗口大小并建立 TCP 连接。**

三次握手的原因：

- 三次握手才可以阻止历史重复连接的初始化（主要原因）
- 三次握手才可以同步双方的初始序列号
- 三次握手才可以避免资源浪费

> 阻止历史重复连接的初始化

客户端连续发送多次 SYN 建立连接的报文，在网络拥堵等情况下：

- 一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；
- 那么此时服务端就会回一个 `SYN + ACK` 报文给客户端；
- 客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 `RST` 报文给服务端，表示中止这一次连接。

如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：

- 如果是历史连接（序列号过期或超时），则第三次握手发送的报文是 `RST` 报文，以此中止历史连接；
- 如果不是历史连接，则第三次发送的报文是 `ACK` 报文，通信双方就会成功建立连接；

> 同步双方的初始序列号

TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：

- 接收方可以去除重复的数据；
- 接收方可以根据数据包的序列号按序接收；
- 可以标识发送出去的数据包中， 哪些是已经被对方收到的；

可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 `SYN` 报文的时候，需要服务端回一个 `ACK` 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，**这样一来一回，才能确保双方的初始序列号能被可靠的同步。**

> 避免资源浪费

如果只有「两次握手」，当客户端的 `SYN` 请求连接在网络中阻塞，客户端没有接收到`ACK` 报文，就会重新发送 `SYN` ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 `ACK` 确认信号，所以每收到一个 `SYN` 就只能先主动建立一个连接，这会造成什么情况呢？

如果客户端的 `SYN` 阻塞了，重复发送多次 `SYN` 报文，那么服务器在收到请求后就会**建立多个冗余的无效链接，造成不必要的资源浪费。**

#### 关闭TCP连接的前奏

- 标志位
  - FIN：释放一个连接
  - ACK：确认序号有效
- 状态
  - FIN_WAIT_1：发送了关闭TCP连接的请求，等待服务器端回应
  - FIN_WAIT_2：收到服务器端的关闭TCP连接的确认，等待服务器端处理完数据后回应
  - TIME_WAIT ：收到服务器端的关闭连接请求
  - CLOSE_WAIT：等待客户端的关闭连接请求
  - LAST_ACK：服务器准备好和客户端断开连接了
  - CLOSED：代表连接关闭

![image-20201018221012457]()

#### 关闭TCP的四次挥手总结

- 第一次挥手:客户端打算关闭连接，此时会发送一个 TCP 首部 `FIN` 标志位被置为 `1` 的报文，也即 `FIN` 报文，Seq序号=m，之后客户端进入 `FIN_WAIT_1` 状态。
- 第二次挥手: 服务端收到该报文后，就向客户端发送 `ACK` 应答报文，Ack确认序号为m+1，接着服务端进入`CLOSED_WAIT` 状态。
- 客户端收到服务端的 `ACK` 应答报文后，之后进入 `FIN_WAIT_2` 状态。
- 第三次挥手: 等待服务端处理完数据后，也向客户端发送 `FIN` 报文，Seq序号=n , Ack确认号=m+1，用来关闭Server到Client的数据传送，之后服务端进入`LAST_ACK` 状态。
- 第四次挥手: 客户端收到服务端的 `FIN` 报文后，回一个 `ACK` 应答报文，Ack确认序号=n+1，之后进入`TIME_WAIT` 状态。
- 服务器收到了 `ACK` 应答报文后，就进入了 `CLOSE` 状态，至此服务端已经完成连接的关闭。
- 客户端在经过 `2MSL` 一段时间后，自动进入 `CLOSE` 状态，至此客户端也完成连接的关闭。

这里一点需要注意是：**主动关闭连接的，才有 TIME_WAIT 状态。**

#### 为什么挥手需要四次？

再来回顾下四次挥手双方发 `FIN` 包的过程，就能理解为什么需要四次了。

- 关闭连接时，客户端向服务端发送 `FIN` 时，仅仅表示**客户端不再发送数据了但是还能接收数据**。
- 服务器收到客户端的 `FIN` 报文时，先回一个 `ACK` 应答报文，而**服务端可能还有数据需要处理和发送**，等服务端不再发送数据时，才发送 `FIN` 报文给客户端来表示同意现在关闭连接。

从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 `ACK` 和`FIN` 一般都会分开发送，从而比三次握手导致多了一次。

## HTTP与HTTPS

- HTTP：Hyper Text Transfer Protocol 超文本传输协议
  - 定义：客户端和服务器端请求和应答的标准，用于从WEB服务器传输超文本到本地浏览器的传输协议。
  - HTTP请求：按照协议规则先向WEB服务器发送的将超文本传输到本地浏览器的请求
- HTTPS：Hyper Text Transfer Protocol Secure 超文本传输安全协议
  - 定义：HTTP的安全版（安全基础是SSL/TLS）
  - SSL：Secure Sockets Layer 安全套接层
  - TLS：Transport Layer Security 传输层安全
  - 为网络通信提供安全及数据完整性的一种安全协议，对网络连接进行加密
- 区别：
  1. HTTP是不安全的（监听和中间人攻击等手段，获取网站账户信息和敏感信息），HTTPS可防止被攻击
  2. HTTP协议的传输内容都是明文，直接在TCP连接上运行，客户端和服务器都无法验证对方身份
  3. HTTPS协议的传输内容都被SSL/TLS加密，且运行在SSL/TLS上，SSL/TLS运行在TCP连接上，所以数据传输是安全的

### Http基本概念

#### 超文本传输协议的详细介绍

##### 定义

- 协议：它使用计算机能够理解的语言确立了一种计算机之间**交流通信**的规范（**两个以上的参与者**），以及相关的各种**控制和错误处理方式**（**行为约定和规范**）。
- 传输：
  - HTTP 协议是一个**双向协议**。
  - 我们在上网冲浪时，浏览器是请求方 A ，百度网站就是应答方 B。双方约定用 HTTP 协议来通信，于是浏览器把请求数据发送给网站，网站再把一些数据返回给浏览器，最后由浏览器渲染在屏幕，就可以看到图片、视频了。
  - 允许中间有**中转或接力**，在 HTTP 里，需要中间人遵从 HTTP 协议，只要不打扰基本的数据传输，就可以添加任意额外的东西。
- 超文本：
  - 就是**超越了普通文本的文本**，它是文字、图片、视频等的混合体最关键有超链接，能从一个超文本跳转到另外一个超文本。

**HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。**

##### 概况

HTTP 是**超文本传输协议**，它定义了**客户端和服务器之间交换报文的格式和方式**，默认使用 80 端口。它使用 **TCP 作为传输层协议**，保证了数据传输的可靠性。

- HTTP 是一个**无状态**的协议，HTTP 服务器不会保存关于客户的任何信息。
- HTTP 有两种连接模式，一种是**持续连接**，一种**非持续连接**。非持续连接指的是服务器必须为每一个请求的对象建立和维护 一个全新的连接。
  - 持续连接下，**TCP 连接默认不关闭，可以被多个请求复用**。采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间。
  - 在 HTTP1.0 以前使用的非持续的连接，但是**可以在请求时，加上 `Connection: keep-alive`** 来要求服务器不要关闭 TCP 连接。**HTTP1.1 以后默认采用的是持续的连接**。目前对于同一个域，大多数浏览器同时建立 6 个持久连接。

#### http常见的状态码

![image-20210313001228992](https://gitee.com/lu_jianping/the-front-end-knowledge/raw/master/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3.assets/image-20210313001228992.png)

- **1xx**：成功接收了请求，但是处理过程还没结束，需要客户端再抛出一个请求才能完成整个过程。这个比较少见，大家了解即可。

- 2xx

  ：表示成功接收请求、并且已经处理完毕。其中需要重点关注下面这个码：

  - 200 OK，标识客户端的请求已经被服务器正确处理

- 3xx

  ：表示服务器虽然也处理了你的请求，但客户端还需要进一步的工作，才可以完成请求。其中需要大家重点关注的是：

  - 301：**永久性**重定向，表示资源已被分配了新的 URL
  - 302：**临时性**重定向，表示资源临时被分配了新的 URL
  - 304，表示服务器校验后发现资源没有改变，提醒客户端直接**走缓存来取资源**

- 4xx

  ：客户端错误，意味着请求出错了。需要关注的重点错误码是：

  - 400：请求报文存在语法错误
  - 403：对请求资源的访问被服务器拒绝（多半是没权限）
  - 404，资源不存在，可能是你的路径不对，也可能是这个资源在服务端已经被下掉了

- 5xx

  ：服务器错误，意味着服务器内部的程序处理有问题。需要关注的重点错误码是：

  - 500：服务器在接受请求后进行处理的过程中，发生了内部错误
  - 502：网关错误
  - 504：网关超时

#### http常见的字段（首部行）

首部可以分为四种首部，**请求首部、响应首部、通用首部和实体首部**。通用首部和实体首部在请求报文和响应报文中都可以设置，区别在于请求首部和响应首部。

##### 请求首部

- Host：客户端发送请求时，用来指定服务器的域名

  - ```
    Host: www.A.com
    ```

    有了 `Host` 字段，就可以将请求发往「同一台」服务器上的不同网站。

- 客户端请求的时候，可以使用 `Accept` 字段声明自己可以接受哪些数据格式、`Accept-Charset可接收的字符集`。

  ```
  Accept: */*
  ```

  上面代码中，客户端声明自己可以接受任何格式的数据。

##### 响应首部

常见的响应首部有 ETag 资源的匹配信息，Location 客户端重定向的 URI。

##### 通用首部

- Connection：用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。

  HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定`Connection` 首部字段的值为 `Keep-Alive`。

  ```
  Connection: keep-alive
  ```

  一个可以复用的 TCP 连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段。

- Cache-Control：指明哪些地方可以缓存返回的数据，指明到期时间(缓存的有效期)

  ```
  'Cache-Control': 'max-age=20, public'
  ```

  缓存时间为20s，返回的内容所经过的任何路径中，包括中间的一些HTTP 代理服务器以及发出请求的客户端浏览器，都可以进行对返回内容的缓存操作

##### 实体首部

- Content-Length：表明本次回应的数据长度

  - ```
    Content-Length: 1000
    ```

    如上面则是告诉浏览器，本次服务器回应的数据长度是 1000 个字节，后面的字节就属于下一个回应了。

- Content-Type：用于服务器回应时，告诉客户端，本次数据是什么格式。

  ```
  Content-Type: text/html; charset=utf-8
  ```

  上面的类型表明，发送的是网页，而且编码是UTF-8。

- Content-Encoding：说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式

  ```
  Content-Encoding: gzip
  ```

  上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。

  客户端在请求时，用 `Accept-Encoding` 字段说明自己可以接受哪些压缩方法。

  ```
  Accept-Encoding: gzip, deflate
  ```

  - Expires 实体主体的过期时间、Last-Modified 资源的最后修改时间等

#### http常见的请求方法

**HTTP1.0**定义了三种请求方法：GET, POST 和 HEAD方法。 HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。

1. **OPTIONS**：即**预检请求**，可用于**检测服务器允许的http方法**。当发起**跨域请求**时，由于安全原因，触发一定条件时浏览器会在正式请求之前自动先发起OPTIONS请求，即**CORS预检请求**，服务器若接受该跨域请求，浏览器才继续发起正式请求。
2. **HEAD**: 向服务器索与**GET请求相一致**的响应，只不过**响应体将不会被返回**，**用于获取报头**。
3. **GET**：向特定的资源发出请求。注意：GET方法**不应当被用于产生“副作用”的操作中**
4. **POST**：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求**可能会导致新的资源的建立和/或已有资源的修改**。
5. **PUT**：向指定资源位置**上传其最新内容**，PUT 在能力上和 POST 类似，区别在于 **PUT 的 URI 指向是具体的某个资源**，而不能指向资源集合。同时 PUT 对资源的修改是幂等的。
6. **DELETE**：请求服务器**删除Request-URL所标识的资源**
7. **TRACE**：**回显服务器收到的请求**，主要用于测试或诊断
8. **CONNECT**：HTTP/1.1协议中预留给能够将连接改为**管道方式**的**代理服务器**

###### GET和POST请求

**两者的区别**

`Get` 方法的含义是请求**从服务器获取资源**，这个资源可以是静态的文本、页面、图片视频等。

而`POST` 方法则是相反操作，它向 `URI` 指定的资源提交数据，数据就放在报文的 body 里。

**GET 和 POST 方法都是安全和幂等的吗？**

先说明下安全和幂等的概念：

- 在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。
- 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。

那么很明显 **GET 方法就是安全且幂等的**，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。

**POST** 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是**不安全**的，且多次提交数据就会创建多个资源，所以**不是幂等**的。

#### http 请求报文

HTTP 请求报文的格式如下：

```
GET / HTTP/1.1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
Accept: */*
```

HTTP 请求报文的**第一行叫做请求行**，**后面的行叫做首部行**，**首部行后还可以跟一个实体主体**。**请求首部之后有一个空行**，这个空行不能省略，它**用来划分首部与实体**。

- **请求行**包含三个字段：**方法字段、URL 字段和 HTTP 版本字段**。

#### http响应报文

HTTP 响应报文的格式如下：

```
HTTP/1.0 200 OK
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84

<html>
  <body>Hello World</body>
</html>
```

HTTP 响应报文的**第一行叫做状态行**，**后面的行是首部行**，**最后是实体主体**。

- **状态行**包含了三个字段：**协议版本字段**、**状态码**和**相应的状态信息**。
- **实体部分**是报文的主要部分，它**包含了所请求的对象**。

### HTTP缓存：强制缓存和协商缓存

良好的缓存机制可以减少资源的重复加载以提高网页的整体加载效率

#### 缓存原理

1. 浏览器在加载资源的时候，会根据请求头的**`expires`和`cache-control`**来判断是否命中**强缓存**，若命中则直接从缓存读取数据，不会发送请求到服务器。
2. 如果没有命中强缓存，则浏览器会发送一个请求到服务器，通过请求头的**`last-modified`和`etag`**来验证是否命中**协商缓存**。当向服务端发起缓存校验的请求时，服务端会返回 200 ok表示返回正常的结果或者 **304 Not Modified(不返回body)表示浏览器可以使用本地缓存文件**。304的响应头也可以同时**更新缓存文档的过期时间**
3. 如果前面两者都没有命中，直接从服务器加载资源。

#### 实现方式

**强缓存通过Expires和Cache-Control实现**。 **协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的**。

> Expires Expires是http1.0提出的一个表示资源过期时间的header，它是一个**绝对时间**，由服务器返回。Expires **受限于本地时间**，如果修改了本地时间，可能会造成缓存失效。 Expires: Wed, 11 May 2018 07:20:00 GMT

> Cache-Control Cache-Control 出现于 HTTP / 1.1，**优先级高于 Expires** , 表示的是**相对时间**。

```
no-store：没有缓存。缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。
no-cache: 缓存但重新验证。每次有请求发出时，缓存会将此请求发到服务器（译者注：该请求应该会带有与本地缓存相关的验证字段），服务器端会验证请求中所描述的缓存是否过期，若未过期（返回304），则缓存才使用本地缓存副本。
private：只允许客户端浏览器缓存。
public: 允许所有用户缓存。例如中间代理、CDN等
max-age=<seconds>：表示资源能够被缓存的最大时间。相对Expires而言，max-age是距离请求发起的时间的秒数。针对应用中那些不会改变的文件，通常可以手动设置一定的时长以保证缓存有效，例如图片、css、js等静态资源。
must-revalidate:触发缓存验证。验证它的状态，已过期的缓存将不被使用
```

> Last-Modified，If-Modified-Since Last-Modified表示**本地文件最后修改日期**，浏览器会在request header加 If-Modified-Since（上次返回的Last-Modified的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。

但是**如果在本地打开缓存文件，就会造成 Last-Modified 被修改**，所以在 HTTP / 1.1 出现了 ETag。

> ETag、If-None-Match Etag就像一个指纹，资源变化都会导致ETag变化，跟最后修改时间没有关系，ETag可以**保证每一个资源是唯一的**。

If-None-Match的header会将上次返回的Etag发送给服务器，询问该资源的Etag是否有更新，有变动就会发送新的资源回来。

**ETag的优先级比Last-Modified更高**。

具体为什么要用ETag，主要出于下面几种情况考虑：

- 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；
- 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；
- 某些服务器不能精确的得到文件的最后修改时间。

### HTTP的特性（HTTP的发展以及解决的问题）

![image-20210425120441943](https://gitee.com/lu_jianping/the-front-end-knowledge/raw/master/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3.assets/image-20210425120441943.png)

#### 你知道的 HTTP（1.1） 的优点有哪些，怎么体现的？

HTTP 最凸出的优点是**「简单、灵活和易于扩展、应用广泛和跨平台」**

*1. 简单*

HTTP 基本的报文格式就是 `header + body`，头部信息也是 `key-value` 简单文本的形式，**易于理解**，降低了学习和使用的门槛。

*2. 灵活和易于扩展*

HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员**自定义和扩充**。

同时 HTTP 由于是工作在应用层（ `OSI` 第七层），则它**下层可以随意变化**。

HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚至把 TCPP 层换成了基于 UDP 的 QUIC。

*3. 应用广泛和跨平台*

互联网发展至今，HTTP 的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP 的应用**片地开花**，同时天然具有**跨平台**的优越性

#### 那它的缺点呢？

HTTP 协议里有优缺点一体的**双刃剑**，分别是**「无状态、明文传输」**，同时还有一大缺点**「不安全」**。

*1. 无状态双刃剑*

无状态的**好处**，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。

无状态的**坏处**，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。

*2. 明文传输双刃剑*

明文意味着在传输过程中的信息，是可方便阅读的，通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。

但是这正是这样，HTTP 的所有信息都暴露在了光天化日下，相当于**信息裸奔**。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取，如果里面有你的账号密码信息，那**你号没了**。

*3. 不安全*

HTTP 比较严重的缺点就是不安全：

- 通信使用明文（不加密），内容可能会被窃听。比如，**账号信息容易泄漏，那你号没了。**
- 不验证通信方的身份，因此有可能遭遇伪装。比如，**访问假的淘宝、拼多多，那你钱没了。**
- 无法证明报文的完整性，所以有可能已遭篡改。比如，**网页上植入垃圾广告，视觉污染，眼没了。**

HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 层，使得在安全上达到了极致。

#### HTTP 想要保存状态的方式

- **`cookie`**：cookie 是存储在浏览器的小段文本，会在浏览器每次向同一服务器再发起请求时被携带并发送到服务器上。我们可以把状态信息放在cookie里，带给服务器。
- **`session`**：session 是存储在服务器的用户数据。浏览器第一次向服务器发起请求时，服务器会为当前会话创建一个session，并且**把对应的 session-id 写入 cookie 中，用来标识 session**。此后，每次用户的请求都会携带一个包含了 session-id 的 cookie，服务器解析出了 session-id，便能定位到用户的用户信息。

#### 那你说下 HTTP/1.1 的性能如何？（解决了哪些问题）

HTTP 协议是基于 **TCP/IP**，并且使用了「**请求 - 应答**」的通信模式，所以性能的关键就在这**两点**里。

*1. 长连接*（**一个 TCP 连接里可以进行多次 HTTP 通信的机制**）

早期 HTTP/1.0：**每发起一个请求，都要新建一次 TCP 连接（三次握手）**，而且是串行请求，增加了通信的开销

为了解决上述 TCP 连接问题，HTTP/1.1 提出了**长连接**的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。

持久连接的特点是，只要**任意一端没有明确提出断开连接，则保持 TCP 连接状态**。通过connect字段控制

*2. 管道网络传输*（基于长连接的）（**允许多个HTTP请求批量地提交给服务器**）

HTTP/1.1 采用了**长连接**的方式，这使得管道（pipeline）网络传输成为了可能。

即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以**减少整体的响应时间。**

管道机制则是允许浏览器**同时**发出 A 请求和 B 请求。

但是服务器还是按照**顺序**，先回应 A 请求，完成后再回应 B 请求。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为**「队头堵塞」**。

*3. 队头阻塞*（**尽管请求是并行的，但响应还是串行的**）

**「请求 - 应答」的模式**加剧了 HTTP 的性能问题。

因为当顺序发送的**请求序列中的一个请求**因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据

为了避免这个问题，一个是减少请求数，一个是同时打开多个持久连接。这就是我们对网站优化时，使用雪碧图、合并脚本的 原因。

**总之 HTTP/1.1 的性能一般般，后续的 HTTP/2 和 HTTP/3 就是在优化 HTTP 的性能。**

#### HTTP2对性能的改善

**二进制分帧**

在 HTTP1.x 中，数据以文本的格式进行传输，解析起来比较低效。

HTTP2.0 在传输消息时，首先会将消息划分为更小的消息和帧，然后再对其采取二进制格式的编码，确保高效的解析。

**头部压缩**

HTTP2.0 中，客户端和服务器分别会维护一份相同的静态字典，这个字典用来存储常见的头部名称，以及常见的头部名称和值的组合。同时还会维护一份相同的动态字典，这个字典可以实时被更新。

如此一来，第一次相互通信过后，后面的请求只需要发送与前面请求之间头部不同的地方，其它的头部信息都可以从字典中获取。相对于 HTTP1.x 中每次都要携带整个头部跑来跑去的笨重操作来说，大大节省了网络开销。

**服务端推送**

在 HTTP1.x 中，如果用户请求了资源 A，结果发现自己如果要用资源 A，那么必须依赖资源 B，这时他不得不再消耗一个请求。

而 HTTP2.0 中，允许服务器主动向客户端 push 资源。也就是说当服务器发现客户端请求了资源 A，却忘了请求资源 A 依赖的资源 B 时，它可以主动将资源 B 顺手推送给客户端。

这样一来，当客户端发现自己漏掉一个必要请求的时候，直接从缓存中就可以读到资源 B 了，而不必再消耗一个请求。

**多路复用**

前面咱们已经提到，HTTP1.x 并不能真正解决队头阻塞的问题。

HTTP1.x 解决不了的问题，HTTP2.0 来解决！

**没错，多路复用其实就是进化版的长连接。**

在 HTTP 2.0 中，一次连接建立后，只要这个连接还在，那么客户端就可以在一个链接中批量发起多个请求。同时，请求与请求间完全不阻塞，A 请求的响应就算没回来，也不影响 B 请求收到自己的响应。请求与请求间做到了高度的独立，真正实现了并行请求。由此，彻底规避了队头阻塞问题。

### HTTPS相关

![image-20210315115436204](https://gitee.com/lu_jianping/the-front-end-knowledge/raw/master/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3.assets/image-20210315115436204.png)

HTTPS是以安全为目标的Http通道，是Http的安全版。Https的安全基础是SSL。**SSL协议位于TCP/IP协议与各种应用层协议之间**，为数据通讯提供安全支持。SSL协议可分为两层：**SSL记录协议**（SSL Record Protocol），它建立在可靠的**传输协议（如TCP）之上**，为高层协议**提供数据封装、压缩、加密等基本功能的支持**。

**SSL握手协议**（SSL Handshake Protocol），它建立在**SSL记录协议之上**，用于在实际的数据传输开始前，通讯双方进行**身份认证、协商加密算法、交换加密密钥等**。

#### HTTP 与 HTTPS 有哪些区别？

1. HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，**在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输**。
2. HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，**还需进行 SSL/TLS 的握手过程，才可进入加密报文传输**。
3. HTTP 的端口号是 80，HTTPS 的端口号是 443。**默认端口号的不同**
4. HTTPS 协议**需要向 CA（证书权威机构）申请数字证书**，来保证服务器的身份是可信的。

#### TLS 和 SSL 协议

- TLS 是安全传输层协议
- TLS 前身是 SSL 安全套接字协议

#### HTTPS 解决了 HTTP 的哪些问题？

HTTP 由于是明文传输，所以安全上存在以下三个风险：

- **窃听风险**，比如通信链路上可以获取通信内容，用户号容易没。
- **篡改风险**，比如强制入垃圾广告，视觉污染，用户眼容易瞎。
- **冒充风险**，比如冒充淘宝网站，用户钱容易没。

HTTPS可以很好的解决了上述的风险：

- **信息加密**：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。
- **校验机制**：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。
- **身份证书**：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。

#### HTTPS是如何解决上述三个风险的？

- **混合加密**的方式实现信息的**机密性**，解决了窃听的风险。
- **摘要算法**的方式来实现**完整性**，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。
- 将服务器公钥放入到**数字证书**中，解决了冒充的风险。

#### HTTPS的缺点

1）Https协议握手阶段比较费时，会使**页面的加载时间延长**。 2）Https**连接缓存不如Http高效**，会增加数据开销，甚至已有的安全措施也会因此而受到影响； 3）SSL证书通常**需要绑定IP**，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。 4）Https协议的**加密范围也比较有限**。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。

#### TLS握手过程

1. 第一步，客户端向服务器发起请求，请求中包含使用的**协议版本号**、**生成的一个随机数**、以及**客户端支持的加密方法**。
2. 第二步，服务器端接收到请求后，**确认双方使用的加密方法**、并**给出服务器的证书**、以及一个**服务器生成的随机数**。
3. 第三步，客户端**确认服务器证书有效后**，**生成一个新的随机数**，并**使用数字证书中的公钥加密这个随机数**，然后发给服务器。并且还会提供一个前面所有内容（第一和第二步的通信信息）的 hash 的值，用来供服务器检验。
4. 第四步，服务器**使用自己的私钥，来解密客户端发送过来的随机数**。并提供前面所有内容的 hash 值来供客户端检验。
5. 第五步，客户端和服务器端**根据约定的加密方法使用前面的三个随机数，生成对话秘钥**，以后的对话过程都使用这个秘钥来加密信息。

#### TLS 如何保证传输的安全

TLS 的握手过程主要用到了三个方法来保证传输的安全。

首先是**对称加密的方法**，对称加密的方法是，**双方使用同一个秘钥对数据进行加密和解密**。但是对称加密的存在一个问题，就 是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。这就要用到非对称加密的方法。

**非对称加密**的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。

用私钥加密的数据，只有对应的公钥才能解密，**用公钥加密的数据，只有对应的私钥才能解密**。

我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。

但是非对称加密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。

因此我们可以**使用对称加密和非对称加密结合的方式**，因为对称加密的方式的缺点是无法保证秘钥的安全传输，因此我们可以**用非对称加密的方式来对对称加密的秘钥进行传输，然后以后的通信使用对称加密的方式来加密**，这样就解决了两个方法各自存 在的问题。

但是现在的方法也不一定是安全的，因为我们**没有办法确定我们得到的公钥就一定是安全的公钥**。

可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而我们自己还不知道。

为了解决这样的问题，我们可以**使用数字证书的方式**，首先我们使用一种 Hash 算法来对我们的公钥和其他信息进行加密生成一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。

最后**将原始的信息和签名合在一起**，称为**数字证书**。

当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和我们生成的摘要进行对比，就能发现我们得到的信息是否被更改 了。

这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样我们才能保证数据的安全。

### 跨域问题的解决

